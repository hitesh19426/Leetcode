class DSU{
    vector<int> parent, size, infected;
public:
    int count = 0;
    
    DSU(int n) : parent(n), size(n), infected(n) {
        for(int i=0; i<n; i++)
            make_set(i);
    }
    
    void make_set(int v, bool isInfected = false){
        parent[v] = v;
        size[v] = 1;
        infected[v] = 0;
        count++;
    }
    
    void set_infected(int v){
        infected[v] = 1;
    }
    
    int find_set(int v){
        if(v == parent[v])
            return v;
        return parent[v] = find_set(parent[v]);
    }
    
    void union_set(int a, int b){
        a = find_set(a);
        b = find_set(b);
        if(a != b){
            if(size[a] < size[b])
                swap(a, b);
            parent[b] = a;
            size[a] += size[b];
            infected[a] += infected[b];
            count--;
        }
    }
    
    int count_infected(int v){
        v = find_set(v);
        return infected[v];
    }
    
    int count_size(int v){
        v = find_set(v);
        return size[v];
    }
};

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        DSU dsu(n);
        
        for(int i=0; i<initial.size(); i++){
            dsu.set_infected(initial[i]);
        }
        
        for(int i=0; i<n; i++){
            for(int j=i+1; j<n; j++){
                if(graph[i][j]){
                    dsu.union_set(i, j);
                }
            }
        }
        
        int ind = -1;
        sort(initial.begin(), initial.end());
        for(int v: initial){
            if(dsu.count_infected(v) == 1 && (ind == -1 || dsu.count_size(v) > dsu.count_size(ind)))
                ind = v;
        }
        return (ind == -1 ? initial[0] : ind);
    }
};
/*
TC = n*n*akerman(n) + nlogn  + n*akerman(n)
SC = n
*/