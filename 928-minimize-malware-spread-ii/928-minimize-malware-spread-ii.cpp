class DSU{
	vector<int> parent, size;
public:
	int count = 0;
	DSU(int n) : parent(n), size(n), count(0) {}

	void make_set(int v){
        if(size[v] == 0){
            parent[v] = v;
            size[v] = 1;
            count++;   
        }
	}

	int find_set(int v){
		if(v == parent[v])
			return v;
		return parent[v] = find_set(parent[v]);
	}

	bool union_set(int a, int b){
		a = find_set(a);
		b = find_set(b);
		if(a != b){
			if(size[a] < size[b])
				swap(a, b);
			parent[b] = a;
			size[a] += size[b];
			count--;
			return true;
		}
		return false;
	}
    
    int find_size(int v){
        v = find_set(v);
        return size[v];
    }
};

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        vector<bool> infected(n, false);
        for(int& x: initial)
            infected[x] = true;
        
        DSU uf(n);
        for(int i=0; i<n; i++){
            if(!infected[i])
                uf.make_set(i);
        }
        for(int i=0; i<n; i++){
            for(int j=0; j<n; j++){
                if(graph[i][j] && !infected[i] && !infected[j]){
                    uf.union_set(i, j);
                }
            }
        }
        
        vector<unordered_set<int>> groups(n);  // groups[i] = groups connected to infected node i
        vector<unordered_set<int>> count(n);       // infected nodes connected to group[i]
        for(int i=0; i<n; i++){
            for(int j=i+1; j<n; j++){
                if(graph[i][j]){
                    if(infected[i] && !infected[j]){
                        // cout << i << " " << j << endl;
                        groups[i].insert(uf.find_set(j));
                        count[uf.find_set(j)].insert(i);
                    }
                    if(!infected[i] && infected[j]){
                        // cout << i << " " << j << endl;
                        groups[j].insert(uf.find_set(i));
                        count[uf.find_set(i)].insert(j);
                    }
                }
            }
        }
        
        int ans = -1, max_nodes = -1;
        sort(initial.begin(), initial.end());
        for(int& x: initial){
            int nodes = 0;
            // cout << x << " ";
            for(auto& group: groups[x]){
                // cout << group << " " << uf.find_size(group) << " ";
                if(count[group].size() == 1){
                    // cout << group;
                    nodes += uf.find_size(group);
                }
                // cout << "          ";
            }
            // cout << endl;

            if(nodes > max_nodes)
                max_nodes = nodes, ans = x;
        }
        return ans;
    }
};
/*
TC(N) = O(N + N*N*logN + N*N*logN + N*logN) = O(N*N*logN)
SC(N) = O(N)
*/